{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Specular","text":"<p>Specular is a \"Spec-as-Source\" AI coding framework. It treats rigorous, SRS-style specifications as the source of truth and uses LLMs to compile them into executable code.</p>"},{"location":"#why-specular","title":"Why Specular?","text":"<p>Code is often messy, poorly documented, and prone to drift from original requirements. Specular flips the script:</p> <ol> <li>Write the Spec: Define your component in structured Markdown.</li> <li>Compile to Code: Specular uses LLMs (Gemini/Claude) to implement the spec.</li> <li>Self-Healing: If tests fail, Specular analyzes the failure and patches the code or tests automatically.</li> </ol>"},{"location":"#core-pillars","title":"Core Pillars","text":"<ul> <li>Contracts over Code: Define what you want, let the AI handle the how.</li> <li>Traceability: Every line of code is directly linked to a Functional Requirement.</li> <li>Multi-Language: Native support for Python and TypeScript.</li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<pre><code>pip install specular-ai\n</code></pre> <p>Or for development:</p> <pre><code>git clone https://github.com/symbolfarm/specular.git\ncd specular\nuv sync\n</code></pre>"},{"location":"getting_started/#quick-start","title":"Quick Start","text":""},{"location":"getting_started/#1-set-your-api-key","title":"1. Set your API key","text":"<p>Specular defaults to Google Gemini.</p> <pre><code>export GEMINI_API_KEY=\"your-key-here\"\n</code></pre>"},{"location":"getting_started/#2-create-a-new-spec","title":"2. Create a new spec","text":"<pre><code>specular create calculator \"A simple calculator with add and multiply\"\n</code></pre>"},{"location":"getting_started/#3-compile-to-code","title":"3. Compile to code","text":"<pre><code>specular compile calculator\n</code></pre>"},{"location":"getting_started/#4-run-tests","title":"4. Run tests","text":"<pre><code>specular test calculator\n</code></pre>"},{"location":"getting_started/#5-auto-fix-if-needed","title":"5. Auto-fix if needed","text":"<pre><code>specular fix calculator\n</code></pre>"},{"location":"concepts/self_healing/","title":"Self-Healing","text":"<p>The self-healing loop is the \"Magic\" of Specular.</p> <p>When a test fails, <code>specular fix</code> executes the following loop:</p> <ol> <li>Analyze: Feed the Spec, the Code, the Test, and the Failure Log to a Senior Engineer LLM agent.</li> <li>Diagnose: The agent determines if the error is in the Code (logic bug) or the Test (hallucinated expectation).</li> <li>Patch: The agent provides a minimal patch to resolve the discrepancy.</li> <li>Verify: The human can then run <code>specular test</code> to confirm the fix.</li> </ol>"},{"location":"concepts/spec_as_source/","title":"Spec-as-Source","text":"<p>In Specular, The Specification is the Source of Truth. </p>"},{"location":"concepts/spec_as_source/#the-lifecycle","title":"The Lifecycle","text":"<ol> <li>Requirement: A human defines a Functional Requirement (e.g., <code>FR-01</code>).</li> <li>Compilation: The LLM reads the spec and generates the implementation.</li> <li>Verification: Tests are generated from the <code>Test Scenarios</code> section.</li> <li>Sync: If you change the code manually, you are creating technical debt. If you change the Spec, you are evolving the software.</li> </ol>"},{"location":"concepts/spec_as_source/#markdown-structure","title":"Markdown Structure","text":"<p>Specular uses a specific SRS (Software Requirements Specification) format:</p> <ul> <li>Frontmatter: YAML metadata (name, type, language, dependencies).</li> <li>Overview: Purpose and context.</li> <li>Interface: Types, inputs, and outputs.</li> <li>Functional Requirements: Detailed behavior.</li> <li>Non-Functional Requirements: Constraints like performance and purity.</li> <li>Design Contract: Pre-conditions and post-conditions.</li> <li>Test Scenarios: High-level test cases.</li> </ul>"},{"location":"examples/math_demo/","title":"Math Demo (Python)","text":"<p>This example demonstrates a basic Python library.</p> <p>View the Spec in the repository</p>"},{"location":"examples/math_demo/#key-features","title":"Key Features","text":"<ul> <li>Pure functions.</li> <li>Factorial and Primality testing.</li> <li>Automatic test generation with <code>pytest</code>.</li> </ul>"},{"location":"examples/ml_demo/","title":"ML Research (PyTorch)","text":"<p>This example demonstrates the Hybrid Workflow for Machine Learning research.</p> <p>In research, you need Reproducibility for your infrastructure (data loaders, model definitions) but Flexibility for your experiments (training loops, logging).</p> <p>View the Code in the repository</p>"},{"location":"examples/ml_demo/#the-architecture","title":"The Architecture","text":"<ol> <li>Specs (Infrastructure):<ul> <li><code>model.spec.md</code>: Defines the Neural Network architecture (layers, dimensions).</li> <li><code>data.spec.md</code>: Defines the Data Pipeline (shapes, preprocessing).</li> </ul> </li> <li>Manual Code (Experiment):<ul> <li><code>train.py</code>: A hand-written script that imports the generated components and runs the training loop.</li> </ul> </li> </ol>"},{"location":"examples/ml_demo/#why-this-approach","title":"Why this approach?","text":"<ul> <li>Prevent Drift: Your model architecture is locked in a spec. You can't accidentally change a layer size without updating the requirements.</li> <li>Rapid Iteration: You can tweak hyperparameters, logging, and optimizers in <code>train.py</code> without needing to recompile the whole system.</li> </ul>"},{"location":"examples/ts_demo/","title":"TS Demo (TypeScript)","text":"<p>This example demonstrates how Specular handles the Node.js ecosystem.</p> <p>View the Spec in the repository</p>"},{"location":"examples/ts_demo/#key-features","title":"Key Features","text":"<ul> <li>Type-safe interfaces.</li> <li>Uses Node.js built-in <code>node:test</code> runner.</li> <li>Zero-config execution via <code>tsx</code>.</li> </ul>"},{"location":"guide/agents/","title":"Agents Guide","text":"<p>SpecSoloist uses native subagents \u2014 agent definitions for Claude Code and Gemini CLI \u2014 to perform multi-step, tool-using compilation tasks. This is the default mode for most commands.</p>"},{"location":"guide/agents/#what-are-native-subagents","title":"What Are Native Subagents?","text":"<p>Native subagents are Markdown files that define an agent's role, tools, and behaviour:</p> <ul> <li>Claude Code: <code>.claude/agents/</code> directory</li> <li>Gemini CLI: <code>.gemini/agents/</code> directory</li> </ul> <p>When you run <code>sp conduct</code>, <code>sp compose</code>, <code>sp fix</code>, or <code>sp respec</code>, SpecSoloist detects which CLI is installed (Claude preferred) and delegates the task to the appropriate agent.</p>"},{"location":"guide/agents/#available-agents","title":"Available Agents","text":"Agent File Role compose <code>.claude/agents/compose.md</code> Draft architecture and specs from natural language conductor <code>.claude/agents/conductor.md</code> Orchestrate builds, resolve dependencies, spawn soloists soloist <code>.claude/agents/soloist.md</code> Compile a single spec into working code and tests respec <code>.claude/agents/respec.md</code> Reverse-engineer existing code into specs fix <code>.claude/agents/fix.md</code> Analyze test failures, patch code, re-test"},{"location":"guide/agents/#how-sp-commands-use-agents","title":"How sp Commands Use Agents","text":"<pre><code>sp conduct src/\n    \u2514\u2500\u2500 Conductor agent\n            \u251c\u2500\u2500 Reads all *.spec.md files\n            \u251c\u2500\u2500 Resolves dependency order\n            \u2514\u2500\u2500 Spawns soloist agents per spec (parallel)\n                    \u251c\u2500\u2500 soloist: config\n                    \u251c\u2500\u2500 soloist: resolver\n                    \u2514\u2500\u2500 soloist: parser ...\n\nsp compose \"build a todo app with auth\"\n    \u2514\u2500\u2500 Compose agent\n            \u251c\u2500\u2500 Drafts architecture\n            \u2514\u2500\u2500 Writes spec files to src/\n\nsp fix mymodule\n    \u2514\u2500\u2500 Fix agent\n            \u251c\u2500\u2500 Reads failing tests\n            \u251c\u2500\u2500 Patches implementation\n            \u2514\u2500\u2500 Re-runs tests (up to 3 retries)\n\nsp respec src/mymodule.py\n    \u2514\u2500\u2500 Respec agent\n            \u251c\u2500\u2500 Reads existing code\n            \u2514\u2500\u2500 Writes spec to src/mymodule.spec.md\n</code></pre>"},{"location":"guide/agents/#usage-with-claude-code","title":"Usage with Claude Code","text":"<pre><code># Default: delegates to Claude agent\nsp conduct src/\n\n# Fully automated (no permission prompts) \u2014 for CI or quine runs\nsp conduct score/ --auto-accept\n\n# Override model\nsp conduct src/ --model claude-haiku-4-5-20251001\n</code></pre>"},{"location":"guide/agents/#usage-with-gemini-cli","title":"Usage with Gemini CLI","text":"<p>If <code>claude</code> is not installed but <code>gemini</code> is, SpecSoloist automatically falls back to Gemini:</p> <pre><code>sp conduct src/\n# \u2192 delegates to gemini agent\n</code></pre>"},{"location":"guide/agents/#-no-agent-fallback","title":"--no-agent Fallback","text":"<p>Pass <code>--no-agent</code> to skip the agent entirely and use direct LLM API calls. This is faster for simple single-spec compilation but loses the multi-step reasoning and tool-use capabilities:</p> <pre><code>sp compile mymodule --no-agent\nsp conduct src/ --no-agent\n</code></pre> <p>Note: <code>--no-agent</code> requires an API key (<code>GEMINI_API_KEY</code> or <code>ANTHROPIC_API_KEY</code>).</p>"},{"location":"guide/agents/#the-quine","title":"The Quine","text":"<p><code>sp conduct score/ --auto-accept</code> runs the quine \u2014 it uses the conductor agent to regenerate SpecSoloist's own source code from its own specs. This validates that all specs are complete and correct.</p> <p>Output goes to <code>build/quine/</code>. Run the generated tests with:</p> <pre><code>PYTHONPATH=build/quine/src uv run python -m pytest build/quine/tests/ -v\n</code></pre>"},{"location":"guide/arrangement/","title":"Arrangement Guide","text":"<p>An Arrangement is a YAML configuration file that tells SpecSoloist how to build your project: where to put generated files, which language and tools to use, and what setup commands to run before tests.</p> <p>Think of it as the bridge between your specs (the what) and your build environment (the how).</p>"},{"location":"guide/arrangement/#auto-discovery","title":"Auto-Discovery","text":"<p>SpecSoloist automatically looks for <code>arrangement.yaml</code> in the current working directory. You can also specify one explicitly:</p> <pre><code>sp compile mymodule --arrangement path/to/arrangement.yaml\nsp conduct --arrangement path/to/arrangement.yaml\nsp test mymodule   # also picks up arrangement.yaml automatically\n</code></pre>"},{"location":"guide/arrangement/#annotated-example","title":"Annotated Example","text":"<pre><code># arrangement.yaml\n\nlanguage: python\n\noutput:\n  implementation: src/mypackage/{name}.py   # {name} is the spec name\n  tests: tests/test_{name}.py\n\nenvironment:\n  tools:\n    - uv\n    - pytest\n  setup_commands:\n    # These run in the build directory before each test run\n    - uv pip install -e .\n    - uv pip install pytest\n\nbuild:\n  lint: uv run ruff check src/\n  test: uv run python -m pytest {file} -v\n</code></pre>"},{"location":"guide/arrangement/#fields","title":"Fields","text":"Field Description <code>language</code> Target language (e.g. <code>python</code>, <code>typescript</code>) <code>output.implementation</code> Path template for generated implementation files <code>output.tests</code> Path template for generated test files <code>environment.tools</code> List of tools the agent should use (informational) <code>environment.setup_commands</code> Shell commands run before each test invocation <code>build.lint</code> Command to lint the generated code <code>build.test</code> Command template to run tests (<code>{file}</code> is the test path)"},{"location":"guide/arrangement/#setup_commands","title":"setup_commands","text":"<p><code>setup_commands</code> are shell commands executed in the build directory before running tests. Use them to install dependencies or prepare the environment:</p> <pre><code>environment:\n  setup_commands:\n    - uv pip install -e \".[dev]\"\n</code></pre> <p>Commands run in order. If any command fails, the test run is aborted and the failure is reported.</p>"},{"location":"guide/arrangement/#example-a-typescript-project","title":"Example: A TypeScript Project","text":"<pre><code>language: typescript\n\noutput:\n  implementation: src/{name}.ts\n  tests: tests/{name}.test.ts\n\nenvironment:\n  tools:\n    - node\n    - npm\n  setup_commands:\n    - npm install\n\nbuild:\n  lint: npx eslint src/\n  test: npx jest {file}\n</code></pre> <p>See <code>arrangement.example.yaml</code> in the project root for a complete reference example.</p>"},{"location":"guide/workflow/","title":"The SpecSoloist Workflow","text":"<p>Using SpecSoloist requires a shift in mindset: You are no longer a Coder; you are an Architect.</p> <p>Instead of writing logic, you define constraints and behaviors. This guide outlines the recommended workflow for building scalable systems.</p>"},{"location":"guide/workflow/#1-the-leaves-up-strategy","title":"1. The \"Leaves-Up\" Strategy","text":"<p>Do not try to compile an entire application in one go. Build from the bottom up.</p> <ol> <li>Domain First: Start by defining your data structures (Type Specs). This creates the \"vocabulary\" for your system.</li> <li>Dependencies Second: Build utility modules and helpers that depend on those types.</li> <li>Core Logic Third: Build the business logic that uses the utilities.</li> <li>API/UI Last: Build the interface layer.</li> </ol>"},{"location":"guide/workflow/#example-order","title":"Example Order","text":"<ol> <li><code>types.spec.md</code> (User, Order structs)</li> <li><code>validation.spec.md</code> (Input checkers)</li> <li><code>order_service.spec.md</code> (Business logic)</li> </ol>"},{"location":"guide/workflow/#2-the-iteration-loop","title":"2. The Iteration Loop","text":"<p>Once a component exists, you enter the daily development loop. You rarely touch generated code directly.</p>"},{"location":"guide/workflow/#scenario-a-adding-a-feature","title":"Scenario A: Adding a Feature","text":"<ol> <li>Open <code>auth.spec.md</code>.</li> <li>Add a new function signature to Interface Specification.</li> <li>Add a Functional Requirement (e.g., <code>FR-05: The system shall hash passwords using bcrypt</code>).</li> <li>Run <code>sp compile auth</code>.</li> <li>Run <code>sp test auth</code>. (SpecSoloist generates new tests for the new requirements).</li> </ol>"},{"location":"guide/workflow/#scenario-b-fixing-a-bug","title":"Scenario B: Fixing a Bug","text":"<ol> <li>You run <code>sp test</code> and see a failure.</li> <li>Do not edit the code.</li> <li>Run <code>sp fix auth</code>.</li> <li>The agent analyzes the failure, reads the spec, and patches the code.</li> <li>If it fails repeatedly: Your spec is likely ambiguous. Refine the spec (e.g., add a constraint or clarify an edge case).</li> </ol>"},{"location":"guide/workflow/#3-the-hybrid-reality","title":"3. The Hybrid Reality","text":"<p>For large projects, you don't have to use SpecSoloist for 100% of the code.</p> <ul> <li>SpecSoloist: Use it for \"pure\" logic, data models, complex algorithms, and utilities.</li> <li>Hand-Written: Use manual code for \"glue,\" framework boilerplate (like FastAPI setup or React routing), or highly visual UI components.</li> </ul> <p>SpecSoloist generates standard Python/TypeScript files in your configured output directory. You can import them into your hand-written <code>main.py</code> just like any other library.</p> <p>!!! warning \"Do not edit build artifacts\"     If you manually edit a generated file, SpecSoloist will overwrite your changes the next time you compile. If you need manual control, move the file out of the build directory and stop managing it with SpecSoloist.</p>"},{"location":"guide/workflow/#4-best-practices","title":"4. Best Practices","text":"<ul> <li>NFRs are your Friend: If the code works but is \"bad\" (slow, messy), add a Non-Functional Requirement.<ul> <li>Bad: \"Make it fast.\"</li> <li>Good: \"NFR-Performance: Must use binary search, O(log n).\"</li> </ul> </li> <li>Explicit Dependencies: Ensure your <code>dependencies: []</code> list in the spec frontmatter is accurate. This tells the LLM exactly what other modules it can import.</li> </ul>"},{"location":"reference/cli/","title":"CLI Reference","text":"<p>The <code>sp</code> command-line tool is your primary interface for the framework.</p> Command Description <code>sp list</code> List all specifications in <code>src/</code> <code>sp create &lt;name&gt; &lt;desc&gt;</code> Create a new spec from the template <code>sp compose &lt;request&gt;</code> Draft architecture and specs from natural language <code>sp validate &lt;name&gt;</code> Check a spec for SRS compliance <code>sp conduct [src_dir]</code> Orchestrate a project build (parallel &amp; incremental) <code>sp compile &lt;name&gt;</code> Compile a spec to implementation code and tests <code>sp test &lt;name&gt;</code> Execute the test suite for a component <code>sp fix &lt;name&gt;</code> Analyze failures and attempt an autonomous fix <code>sp respec &lt;file&gt;</code> Reverse engineer existing code into a spec <code>sp perform &lt;workflow&gt;</code> Execute an orchestration workflow <code>sp build</code> Alias for <code>conduct</code>"},{"location":"reference/cli/#build-options","title":"Build Options","text":"<ul> <li><code>--incremental</code>: Only recompile specs that have changed since the last build.</li> <li><code>--parallel</code>: Compile independent specs concurrently.</li> <li><code>--workers &lt;n&gt;</code>: Set the number of parallel workers.</li> <li><code>--model &lt;name&gt;</code>: Override the default LLM model for a specific run.</li> <li><code>--auto-accept</code>: Run non-interactively (agent mode). For <code>sp conduct score/</code>, also enables <code>bypassPermissions</code>.</li> <li><code>--no-agent</code>: Use direct LLM calls instead of delegating to a Claude/Gemini CLI agent.</li> <li><code>--arrangement &lt;path&gt;</code>: Load an Arrangement config file. Auto-discovers <code>arrangement.yaml</code> if omitted.</li> </ul>"},{"location":"reference/cli/#arrangement","title":"Arrangement","text":"<p>An Arrangement file (<code>arrangement.yaml</code>) configures the build environment: output paths, language, tools, and setup commands. It is auto-discovered from the current working directory, or specified explicitly with <code>--arrangement</code>.</p> <p>See the Arrangement guide for full documentation.</p>"},{"location":"reference/cli/#agents","title":"Agents","text":"<p>By default, <code>sp compose</code>, <code>sp conduct</code>, <code>sp fix</code>, and <code>sp respec</code> delegate to a Claude or Gemini CLI agent for multi-step reasoning and tool use. Pass <code>--no-agent</code> to fall back to direct LLM calls.</p> <p>See the Agents guide for details.</p>"},{"location":"reference/template/","title":"Spec Template","text":"<p>When you run <code>specular create</code>, it generates a file based on this standard template.</p> <pre><code>---\nname: [Component Name]\ntype: function\nlanguage_target: python\nstatus: draft\ndependencies: []\n---\n\n# 1. Overview\n[Brief summary of the component's purpose.]\n\n# 2. Interface Specification\n...\n</code></pre>"},{"location":"reference/template/#key-fields","title":"Key Fields","text":"<ul> <li><code>name</code>: The module name.</li> <li><code>type</code>: <code>function</code>, <code>class</code>, <code>module</code>, or <code>typedef</code>.</li> <li><code>language_target</code>: <code>python</code> or <code>typescript</code>.</li> <li><code>dependencies</code>: List of other specs this module depends on.</li> </ul>"}]}